schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface GQL_IServer {
  configState: GQL_ServerConfigState
  description: String
  id: ID!
  isConfigMatch: Boolean
  location: String
  name: String!
  state: GQL_ServerState!
  type: GQL_ServerVariant!
  updated: DateTime!
  uptime: GQL_Uptime
}

interface GQL_IServerEvent {
  asJson: String
  description: String
  iD: ID!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

interface ResultError {
  errorType: String!
  message: String!
}

type AuthorizationError implements ResultError {
  description: String
  errors: [ErrorSource!]
  errorType: String!
  message: String!
}

type CreateMqttAuthClientPayload {
  errors: [CreateMqttAuthClientError!]
  gQL_MqttAuthClient: GQL_MqttAuthClient
  query: Query!
}

type CreateMqttAuthUserPayload {
  errors: [CreateMqttAuthUserError!]
  gQL_MqttAuthUser: GQL_MqttAuthUser
  query: Query!
}

type CreateMqttServerExplorerUserSubPayload {
  errors: [CreateMqttServerExplorerUserSubError!]
  gQL_MqttExplorerSub: GQL_MqttExplorerSub
  query: Query!
}

type CreateServerPayload {
  errors: [CreateServerError!]
  gQL_IServer: GQL_IServer
  query: Query!
}

type CreateUserPayload {
  errors: [CreateUserError!]
  gQL_User: GQL_User
  query: Query!
}

type CreateWebHookPayload {
  errors: [CreateWebHookError!]
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type DTO_AdapterAddresses {
  dhcpServerAddresses: [String!]!
  dnsAddresses: [String!]!
  gatewayAddresses: [String!]!
  multicastAddresses: [String!]!
  unicastAddresses: [String!]!
}

type DTO_AdapterStatistic {
  bytesReceived: Long!
  bytesSent: Long!
}

type EnableDisableServerPayload {
  errors: [EnableDisableServerError!]
  gQL_IServer: GQL_IServer
  query: Query!
}

type EnableGraphqlApiPayload {
  errors: [EnableGraphqlApiError!]
  gQL_Edge: GQL_Edge
  query: Query!
}

type EnableMqttAuthClinetPayload {
  errors: [EnableMqttAuthClinetError!]
  gQL_MqttAuthClient: GQL_MqttAuthClient
  query: Query!
}

type EnableMqttAuthUserPayload {
  errors: [EnableMqttAuthUserError!]
  gQL_MqttAuthUser: GQL_MqttAuthUser
  query: Query!
}

type EnableMqttClientAuthPayload {
  errors: [EnableMqttClientAuthError!]
  gQL_MqttAuthCfg: GQL_MqttAuthCfg
  query: Query!
}

type EnableMqttLoggingPayload {
  errors: [EnableMqttLoggingError!]
  gQL_MqttServer: GQL_MqttServer
  query: Query!
}

type EnableMqttUserAuthPayload {
  errors: [EnableMqttUserAuthError!]
  gQL_MqttAuthCfg: GQL_MqttAuthCfg
  query: Query!
}

type EnableRestApiPayload {
  errors: [EnableRestApiError!]
  gQL_Edge: GQL_Edge
  query: Query!
}

type ErrorSource {
  message: String
  property: String
  propertyNormalised: String
}

type GQL_Adapter implements Node {
  addresses: DTO_AdapterAddresses!
  description: String!
  id: ID!
  interfaceType: NetworkInterfaceType!
  logs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_AdapterLogConnection
  name: String!
  physicalAddress: String!
  state: AdapterState!
  statistic: DTO_AdapterStatistic!
  supportsIpv4: Boolean!
  supportsIpv6: Boolean!
}

"A connection to a list of items."
type GQL_AdapterConnection {
  "A list of edges."
  edges: [GQL_AdapterEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_Adapter]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_AdapterEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_Adapter
}

type GQL_AdapterLog {
  id: ID!
  state: AdapterState!
  timeStamp: DateTime!
}

"A connection to a list of items."
type GQL_AdapterLogConnection {
  "A list of edges."
  edges: [GQL_AdapterLogEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_AdapterLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_AdapterLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_AdapterLog
}

type GQL_Claim {
  type: String
  value: String
}

type GQL_ClientConnected implements GQL_IServerEvent {
  asJson: String
  clientId: String!
  description: String
  iD: ID!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ClientDisconnected implements GQL_IServerEvent {
  asJson: String
  clientId: String!
  description: String
  iD: ID!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ConfigMatch {
  isMatch: Boolean!
  server: GQL_IServer!
  timestamp: DateTime!
}

type GQL_CountByDate {
  count: Long!
  date: DateTime!
}

type GQL_CpuMetrics {
  id: ID!
  privilegedCpuUsed: Float!
  threadCount: Float!
  totalCpuUsed: Float!
  userCpuUsed: Float!
}

type GQL_DefaultAdapter {
  adapter: GQL_Adapter
  id: ID!
}

type GQL_Edge {
  apiGraphql: Boolean!
  apiRest: Boolean!
  description: String
  guid: String!
  id: ID!
  location: String
  location1: String
  location2: String
  location3: String
  name: String!
}

type GQL_FailedJob implements Node {
  exceptionDetails: String!
  exceptionMessage: String!
  exceptionType: String!
  failedAt: DateTime
  id: ID!
  inFailedState: Boolean!
  jobDetail: GQL_JobDetail
  jobName: String
  reason: String!
}

"A connection to a list of items."
type GQL_FailedJobConnection {
  "A list of edges."
  edges: [GQL_FailedJobEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_FailedJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_FailedJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_FailedJob
}

"A connection to a list of items."
type GQL_IServerConnection {
  "A list of edges."
  edges: [GQL_IServerEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_IServer]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_IServerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_IServer
}

"A connection to a list of items."
type GQL_IServerEventUnionConnection {
  "A list of edges."
  edges: [GQL_IServerEventUnionEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_IServerEventUnion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_IServerEventUnionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_IServerEventUnion
}

type GQL_JobDetail {
  jobId: String!
  lastState: String
  methodCall: String
  parametrs: [GQL_JobParameter!]!
}

type GQL_JobParameter {
  name: String!
  value: String!
}

type GQL_JobsStatistic implements Node {
  deleted: Long!
  enqueued: Long!
  failed: Long!
  id: ID!
  processing: Long!
  queues: Long!
  recentFailedByDate: [GQL_CountByDate!]!
  recentSucceededByDate: [GQL_CountByDate!]!
  recurring: Long!
  scheduled: Long!
  servers: Long!
  succeeded: Long!
}

type GQL_MemoryMetrics {
  getAlocatedMemory: Float!
  id: ID!
  memoryUssage: Float!
  memoryWorkingSet: Float!
  nonPagedMemory: Float!
  pagedMemory: Float!
  virtualMemory: Float!
}

type GQL_Metric {
  id: ID!
  name: String!
  serverUid: String!
  timeStamp: DateTime!
  type: String
  unit: String
  value: Any
}

type GQL_MqttAuthCfg {
  clientAuthEnabled: Boolean!
  id: ID!
  userAuthEnabled: Boolean!
}

type GQL_MqttAuthClient {
  clientId: String
  displayName: String
  enabled: Boolean!
  id: ID!
  lastAuthenticate: DateTime
  rules: [GQL_MqttAuthRule!]!
  system: Boolean!
}

"A connection to a list of items."
type GQL_MqttAuthClientConnection {
  "A list of edges."
  edges: [GQL_MqttAuthClientEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttAuthClient]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttAuthClientEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttAuthClient
}

type GQL_MqttAuthLog {
  authClientId: Long
  authUserId: ID
  code: MqttResultCode!
  description: String
  errorMessage: String
  id: ID!
  isSuccess: Boolean!
  jsonMetadata: String
  timeStamp: DateTime!
}

"A connection to a list of items."
type GQL_MqttAuthLogConnection {
  "A list of edges."
  edges: [GQL_MqttAuthLogEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttAuthLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttAuthLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttAuthLog
}

type GQL_MqttAuthRule {
  authAction: AuthAction!
  id: ID!
  mqttAction: MqttAction!
  topic: String
}

type GQL_MqttAuthUser {
  enabled: Boolean!
  id: ID!
  lastAuthenticate: DateTime
  system: Boolean!
  userName: String
}

"A connection to a list of items."
type GQL_MqttAuthUserConnection {
  "A list of edges."
  edges: [GQL_MqttAuthUserEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttAuthUser]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttAuthUserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttAuthUser
}

type GQL_MqttClient {
  clientId: String!
  connectedTimeStamp: DateTime
  disconnectedTimeStamp: DateTime
  endpoint: String
  id: ID!
  isConnected: Boolean!
  lastMessageTimestamp: DateTime
  protocol: DTO_MqttProtocol!
  serverUid: String!
}

"A connection to a list of items."
type GQL_MqttClientConnection {
  "A list of edges."
  edges: [GQL_MqttClientEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttClient]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttClientEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttClient
}

type GQL_MqttClientSession {
  clientUid: ID!
  created: DateTime
  pendingMessages: Long!
  uid: ID!
}

"A connection to a list of items."
type GQL_MqttClientSessionConnection {
  "A list of edges."
  edges: [GQL_MqttClientSessionEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttClientSession]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttClientSessionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttClientSession
}

type GQL_MqttClientStatistics {
  bytesReceived: Long!
  bytesSent: Long!
  clientUid: ID!
  connectedTimestamp: DateTime
  id: ID!
  lastNonKeepAlivePacketReceivedTimestamp: DateTime
  lastPacketReceivedTimestamp: DateTime
  lastPacketSentTimestamp: DateTime
  receivedApplicationMessagesCount: Long!
  receivedPacketsCount: Long!
  sentApplicationMessagesCount: Long!
  sentPacketsCount: Long!
  serverUid: ID!
}

type GQL_MqttClientStatsUpdate {
  clientId: String!
  serverId: String!
  stats: GQL_MqttClientStatistics!
  timestamp: DateTime!
}

type GQL_MqttExplorerSub {
  color: String
  id: ID!
  noLocal: Boolean!
  serverUid: ID
  topic: String
  userUid: ID
}

"A connection to a list of items."
type GQL_MqttExplorerSubConnection {
  "A list of edges."
  edges: [GQL_MqttExplorerSubEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttExplorerSub]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttExplorerSubEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttExplorerSub
}

type GQL_MqttMessage {
  clientId: String
  clientUid: ID
  contentType: String
  dup: Boolean!
  expireInterval: Int!
  id: ID!
  isJsonPayload: Boolean!
  isTextPayload: Boolean!
  isXmlPayload: Boolean!
  payload: [Byte!]
  payloadUtf8Str: String
  qos: Byte!
  responseTopic: String
  retain: Boolean!
  serverUid: ID!
  timeStamp: DateTime!
  topic: String!
  topicUid: ID
}

"A connection to a list of items."
type GQL_MqttMessageConnection {
  "A list of edges."
  edges: [GQL_MqttMessageEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttMessage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttMessageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttMessage
}

type GQL_MqttMessageTemplate {
  contentType: MessageContentType!
  expireInterval: Int
  id: ID!
  payload: String
  qoS: MessageQoS!
  retain: Boolean!
  serverUid: String!
  topic: String
}

"A connection to a list of items."
type GQL_MqttMessageTemplateConnection {
  "A list of edges."
  edges: [GQL_MqttMessageTemplateEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttMessageTemplate]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttMessageTemplateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttMessageTemplate
}

type GQL_MqttNewClient {
  client: GQL_MqttClient!
  timeStamp: DateTime!
}

type GQL_MqttNewTopic {
  timeStamp: DateTime!
  topic: GQL_MqttTopic!
}

type GQL_MqttServer implements GQL_IServer & Node {
  configState: GQL_ServerConfigState
  description: String
  id: ID!
  isConfigMatch: Boolean!
  isEnabled: Boolean!
  isRunning: Boolean!
  location: String
  loggingEnabled: Boolean!
  name: String!
  state: GQL_ServerState!
  type: GQL_ServerVariant!
  updated: DateTime!
  uptime: GQL_Uptime
}

type GQL_MqttServerClientCfg {
  communicationTimeout: Int!
  id: ID!
  maxPendingMessagesPerClient: Int!
  presistentSession: Boolean!
  serverUID: ID!
}

type GQL_MqttServerEndpoint {
  id: ID!
  iPAddress: String!
  port: Long!
  serverUid: ID!
}

type GQL_MqttServerLog {
  exception: String
  logLevel: MqttNetLogLevel!
  message: String
  source: String
  timeStamp: DateTime!
  uid: ID!
}

"A connection to a list of items."
type GQL_MqttServerLogConnection {
  "A list of edges."
  edges: [GQL_MqttServerLogEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttServerLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttServerLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttServerLog
}

type GQL_MqttServerStats {
  connectionsCount: Long!
  id: ID!
  notConsumedCount: Long!
  packetRcvCount: Long!
  packetSndCount: Long!
  publishedTopicCount: Long!
  subscribedTopicCount: Long!
  subscriptionsCount: Long!
}

type GQL_MqttTopic {
  id: ID!
  serverUid: ID!
  stats: GQL_MqttTopicStats!
  topic: String!
}

"A connection to a list of items."
type GQL_MqttTopicConnection {
  "A list of edges."
  edges: [GQL_MqttTopicEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttTopic]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttTopicEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttTopic
}

type GQL_MqttTopicStats {
  id: ID!
  messagesCount: Long!
}

type GQL_OS {
  isBrowser: Boolean!
  platform: PlatformID!
  version: String
}

type GQL_RecurringJob implements Node {
  callName: String!
  createdAt: DateTime
  cron: String!
  error: String
  id: ID!
  jobDetail: GQL_JobDetail
  lastExecution: DateTime
  lastJobId: String!
  lastJobState: GQL_ScheduleState
  nextExecution: DateTime
  queue: String!
  removed: Boolean!
  retryAttempt: Int!
  timeZoneId: String!
}

"A connection to a list of items."
type GQL_RecurringJobConnection {
  "A list of edges."
  edges: [GQL_RecurringJobEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_RecurringJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_RecurringJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_RecurringJob
}

type GQL_RuntimeMetrics {
  cpuMetrics: GQL_CpuMetrics
  memoryMetrics: GQL_MemoryMetrics
  metricHistory(name: GQL_RuntimeMetricSource): [HistorianRecord]
}

type GQL_ServerConfigDiffEvent implements GQL_IServerEvent {
  asJson: String
  configJson: String
  currentConfigJson: String
  description: String
  iD: ID!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerConfigState {
  isConfigMatch: Boolean!
  offlineConfig: String
  offlineTimeStamp: DateTime
  onlineConfig: String
  onlineTimeStamp: DateTime
}

type GQL_ServerErrorEvent implements GQL_IServerEvent {
  asJson: String
  description: String
  exception: String
  iD: ID!
  json: String
  message: String!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerInfoEvent implements GQL_IServerEvent {
  asJson: String
  description: String
  iD: ID!
  message: String!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerMetric {
  description: String
  eventName: String!
  id: ID!
  meterName: String!
  timeStamp: DateTime!
  topic: String!
  unit: String
  value: Any
}

type GQL_ServerStateChangedEvent implements GQL_IServerEvent {
  asJson: String
  description: String
  iD: ID!
  name: String!
  serverUid: ID
  state: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerStateChangedNotification {
  server_Uid: ID
  state: GQL_ServerState!
}

type GQL_SuccessJob implements Node {
  id: ID!
  inSucceededState: Boolean!
  jobDetail: GQL_JobDetail
  name: String!
  succeededAt: DateTime
  totalDuration: Long
}

"A connection to a list of items."
type GQL_SuccessJobConnection {
  "A list of edges."
  edges: [GQL_SuccessJobEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_SuccessJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_SuccessJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_SuccessJob
}

type GQL_SystemEvent {
  description: String
  iD: ID!
  json: String
  name: String!
  timeStamp: DateTime!
  type: EventType!
}

"A connection to a list of items."
type GQL_SystemEventConnection {
  "A list of edges."
  edges: [GQL_SystemEventEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_SystemEvent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_SystemEventEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_SystemEvent
}

type GQL_SystemInfo {
  appUrls: [String]
  id: ID
  machineName: String
  osVersion: GQL_OS
  processName: String
  serverDateTime: DateTime!
  targetFramework: String
  uptime: GQL_Uptime
}

type GQL_Token {
  description: String!
  expiration: DateTime
  id: ID!
  jsonData: String
  subjectId: String!
}

"A connection to a list of items."
type GQL_TokenConnection {
  "A list of edges."
  edges: [GQL_TokenEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_Token]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_TokenEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_Token
}

type GQL_TokenResponse {
  handle: String
  token: GQL_Token!
}

type GQL_Uptime {
  days: Int!
  hours: Int!
  isValid: Boolean!
  minutes: Int!
  uptime: TimeSpan
}

type GQL_User {
  enabled: Boolean!
  firstName: String
  id: ID!
  lastName: String
  sessionId: String
  sub: String!
  userName: String
}

"A connection to a list of items."
type GQL_UserConnection {
  "A list of edges."
  edges: [GQL_UserEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_User]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_UserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_User
}

type GQL_WebHook {
  contentType: String!
  eventGroup: [HookEventGroup!]!
  id: ID!
  isActive: Boolean!
  lastTrigger: DateTime
  name: String!
  secret: String
  serverUid: String
  uid: String!
  webHookUrl: String!
}

"A connection to a list of items."
type GQL_WebHookConnection {
  "A list of edges."
  edges: [GQL_WebHookEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_WebHook]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_WebHookEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_WebHook
}

type GQL_WebHookRecord {
  exception: String
  guid: String!
  hookEventGroup: HookEventGroup!
  id: ID!
  isJsonResponse: Boolean
  isTextHtmlResponse: Boolean
  requestBody: String!
  requestHeaders: String!
  responseBody: String
  responseContentType: String
  result: RecordResult!
  statusCode: Int!
  timestamp: DateTime!
  webHookID: ID
}

"A connection to a list of items."
type GQL_WebHookRecordConnection {
  "A list of edges."
  edges: [GQL_WebHookRecordEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_WebHookRecord]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_WebHookRecordEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_WebHookRecord
}

type GenerateApiTokenPayload {
  errors: [GenerateApiTokenError!]
  gQL_TokenResponse: GQL_TokenResponse
  query: Query!
}

type HistorianRecord {
  timeStamp: DateTime
  value: Any
}

type InternalError implements ResultError {
  error: String
  errorType: String!
  message: String!
}

type IsAdminResult {
  isAdmin: Boolean!
}

type Mutation {
  createMqttAuthClient(input: CreateMqttAuthClientInput!): CreateMqttAuthClientPayload!
  createMqttAuthUser(input: CreateMqttAuthUserInput!): CreateMqttAuthUserPayload!
  createMqttServerExplorerUserSub(input: CreateMqttServerExplorerUserSubInput!): CreateMqttServerExplorerUserSubPayload!
  createServer(request: CreateServerInput!): CreateServerPayload!
  createUser(input: CreateUserInput!): CreateUserPayload!
  createWebHook(input: CreateWebHookInput!): CreateWebHookPayload!
  enableDisableServer(input: EnableDisableServerInput!): EnableDisableServerPayload!
  enableGraphqlApi(input: EnableGraphqlApiInput!): EnableGraphqlApiPayload!
  enableMqttAuthClinet(input: EnableMqttAuthClinetInput!): EnableMqttAuthClinetPayload!
  enableMqttAuthUser(input: EnableMqttAuthUserInput!): EnableMqttAuthUserPayload!
  enableMqttClientAuth(input: EnableMqttClientAuthInput!): EnableMqttClientAuthPayload!
  enableMqttLogging(input: EnableMqttLoggingInput!): EnableMqttLoggingPayload!
  enableMqttUserAuth(input: EnableMqttUserAuthInput!): EnableMqttUserAuthPayload!
  enableRestApi(input: EnableRestApiInput!): EnableRestApiPayload!
  generateApiToken(input: GenerateApiTokenInput!): GenerateApiTokenPayload!
  processServerCmd(input: ProcessServerCmdInput!): ProcessServerCmdPayload!
  publishMqttMessage(input: PublishMqttMessageInput!): PublishMqttMessagePayload!
  removeMqttAuthClient(input: RemoveMqttAuthClientInput!): RemoveMqttAuthClientPayload!
  removeMqttAuthUser(input: RemoveMqttAuthUserInput!): RemoveMqttAuthUserPayload!
  removeMqttServerExplorerUserSub(input: RemoveMqttServerExplorerUserSubInput!): RemoveMqttServerExplorerUserSubPayload!
  removeMqttServerExplorerUserTemplate(input: RemoveMqttServerExplorerUserTemplateInput!): RemoveMqttServerExplorerUserTemplatePayload!
  removeServer(input: RemoveServerInput!): RemoveServerPayload!
  removeUser(input: RemoveUserInput!): RemoveUserPayload!
  removeWebHook(input: RemoveWebHookInput!): RemoveWebHookPayload!
  resetMqttClientStatistic(input: ResetMqttClientStatisticInput!): ResetMqttClientStatisticPayload!
  revokeApiToken(input: RevokeApiTokenInput!): RevokeApiTokenPayload!
  saveMqttExplorerMessageTemplate(input: SaveMqttExplorerMessageTemplateInput!): SaveMqttExplorerMessageTemplatePayload!
  setEdgeDefaultNetworkAdapter(input: SetEdgeDefaultNetworkAdapterInput!): SetEdgeDefaultNetworkAdapterPayload!
  setEdgeDescription(request: SetEdgeDescriptionInput!): SetEdgeDescriptionPayload!
  setEdgeLocation1(request: SetEdgeLocation1Input!): SetEdgeLocation1Payload!
  setEdgeLocation2(request: SetEdgeLocation2Input!): SetEdgeLocation2Payload!
  setEdgeLocation3(request: SetEdgeLocation3Input!): SetEdgeLocation3Payload!
  setEdgeName(request: SetEdgeNameInput!): SetEdgeNamePayload!
  setMqttAuthUserPassword(input: SetMqttAuthUserPasswordInput!): SetMqttAuthUserPasswordPayload!
  setMqttServerClientCommunicationTimeout(input: SetMqttServerClientCommunicationTimeoutInput!): SetMqttServerClientCommunicationTimeoutPayload!
  setMqttServerClientMaxPendingMessages(input: SetMqttServerClientMaxPendingMessagesInput!): SetMqttServerClientMaxPendingMessagesPayload!
  setMqttServerClientPresistSession(input: SetMqttServerClientPresistSessionInput!): SetMqttServerClientPresistSessionPayload!
  setMqttServerEndpoint(input: SetMqttServerEndpointInput!): SetMqttServerEndpointPayload!
  setServerDescription(input: SetServerDescriptionInput!): SetServerDescriptionPayload!
  setServerLocation(input: SetServerLocationInput!): SetServerLocationPayload!
  setServerName(input: SetServerNameInput!): SetServerNamePayload!
  setUserAdmin(input: SetUserAdminInput!): SetUserAdminPayload!
  setUserPassword(input: SetUserPasswordInput!): SetUserPasswordPayload!
  updateUserEnabled(input: UpdateUserEnabledInput!): UpdateUserEnabledPayload!
  updateUserFirstName(input: UpdateUserFirstNameInput!): UpdateUserFirstNamePayload!
  updateUserLastName(input: UpdateUserLastNameInput!): UpdateUserLastNamePayload!
  updateWebHookActiveState(input: UpdateWebHookActiveStateInput!): UpdateWebHookActiveStatePayload!
  updateWebHookEventGroups(input: UpdateWebHookEventGroupsInput!): UpdateWebHookEventGroupsPayload!
  updateWebHookName(input: UpdateWebHookNameInput!): UpdateWebHookNamePayload!
  updateWebHookSecret(input: UpdateWebHookSecretInput!): UpdateWebHookSecretPayload!
  updateWebHookUrl(input: UpdateWebHookUrlInput!): UpdateWebHookUrlPayload!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type ProcessServerCmdPayload {
  errors: [ProcessServerCmdError!]
  gQL_ServerState: GQL_ServerState
  query: Query!
}

type PublishMqttMessagePayload {
  errors: [PublishMqttMessageError!]
  gQL_MqttMessage: GQL_MqttMessage
  query: Query!
}

type Query {
  adapterById(id: ID!): GQL_Adapter!
  adapterLogs(adapter_id: ID! "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_AdapterLogConnection
  adapters("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_AdapterConnection
  apiTokens("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_TokenConnection
  defaultAdapter: GQL_DefaultAdapter!
  edgeInfo: GQL_Edge!
  failedJob(jobid: ID!): GQL_FailedJob!
  failedJobs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_FailedJobConnection
  isAdmin(user_id: ID!): IsAdminResult!
  jobsStatistic: GQL_JobsStatistic!
  me: GQL_User
  mqttAuthClientById(authClient_id: ID!): GQL_MqttAuthClient!
  mqttAuthClients("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttAuthClientConnection
  mqttAuthLogById(log_id: ID!): GQL_MqttAuthLog!
  mqttAuthLogs("Returns the elements in the list that come after the specified cursor." after: String auth_client_id: ID auth_user_id: ID "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttAuthLogConnection
  mqttAuthUserById(authUser_id: ID!): GQL_MqttAuthUser!
  mqttAuthUsers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttAuthUserConnection
  mqttExplorerStoredTemplates("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttMessageTemplateConnection
  mqttExplorerUserStoredSubs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttExplorerSubConnection
  mqttLogById(log_uid: ID! server_id: ID!): GQL_MqttServerLog!
  mqttLogs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int level: MqttNetLogLevel server_uid: ID!): GQL_MqttServerLogConnection
  mqttServerAuthCfg(server_uid: ID!): GQL_MqttAuthCfg!
  mqttServerById(id: ID!): GQL_MqttServer!
  mqttServerClient(server_client_uid: ID! server_uid: ID!): GQL_MqttClient!
  mqttServerClientConfig(server_uid: ID!): GQL_MqttServerClientCfg!
  mqttServerClientRecentMessages("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttMessageConnection
  mqttServerClients("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttClientConnection
  mqttServerClientSession(server_client_uid: ID! server_uid: ID!): GQL_MqttClientSession!
  mqttServerClientStatistic(server_client_uid: ID! server_uid: ID!): GQL_MqttClientStatistics
  mqttServerEndpoint(server_uid: ID!): GQL_MqttServerEndpoint!
  mqttServerMessageById(message_uid: ID! server_uid: ID!): GQL_MqttMessage
  mqttServerRecentMessages("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String client_uid: ID "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID! topic_uid: ID): GQL_MqttMessageConnection
  mqttServerSessions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttClientSessionConnection
  mqttServerStats(server_uid: ID!): GQL_MqttServerStats!
  mqttServerTopicRecentMessages("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttMessageConnection
  mqttServerTopics("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_uid: ID!): GQL_MqttTopicConnection
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  recurringJob(jobid: ID!): GQL_RecurringJob!
  recurringJobs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_RecurringJobConnection
  runtimeMetrics: GQL_RuntimeMetrics!
  serverLogById(log_id: ID!): GQL_IServerEventUnion!
  serverLogs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int server_id: ID!): GQL_IServerEventUnionConnection
  servers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_IServerConnection
  successJob(jobid: ID!): GQL_SuccessJob!
  successJobs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_SuccessJobConnection
  systemInfo: GQL_SystemInfo!
  systemLogById(log_id: ID!): GQL_SystemEvent!
  systemLogs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_SystemEventConnection
  tokenById(token_id: ID!): GQL_Token!
  userById(user_id: ID!): GQL_User!
  userClaims(user_id: ID!): [GQL_Claim!]!
  userRoles(user_id: ID!): [String!]!
  users("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_UserConnection
  webHookById(hook_id: ID!): GQL_WebHook!
  webHookByUid(hook_uid: String!): GQL_WebHook!
  webHookRecordById(record_id: ID!): GQL_WebHookRecord!
  webHookRecords("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int hook_id: ID! "Returns the last _n_ elements from the list." last: Int): GQL_WebHookRecordConnection
  webHooks("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_WebHookConnection
}

type RemoveMqttAuthClientPayload {
  errors: [RemoveMqttAuthClientError!]
  gQL_MqttAuthClient: GQL_MqttAuthClient
  query: Query!
}

type RemoveMqttAuthUserPayload {
  errors: [RemoveMqttAuthUserError!]
  gQL_MqttAuthUser: GQL_MqttAuthUser
  query: Query!
}

type RemoveMqttServerExplorerUserSubPayload {
  errors: [RemoveMqttServerExplorerUserSubError!]
  gQL_MqttExplorerSub: GQL_MqttExplorerSub
  query: Query!
}

type RemoveMqttServerExplorerUserTemplatePayload {
  errors: [RemoveMqttServerExplorerUserTemplateError!]
  gQL_MqttMessageTemplate: GQL_MqttMessageTemplate
  query: Query!
}

type RemoveServerData {
  removed_id: ID
}

type RemoveServerPayload {
  errors: [RemoveServerError!]
  query: Query!
  removeServerData: RemoveServerData
}

type RemoveUserPayload {
  errors: [RemoveUserError!]
  gQL_User: GQL_User
  query: Query!
}

type RemoveWebHookPayload {
  errors: [RemoveWebHookError!]
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type ResetMqttClientStatisticPayload {
  errors: [ResetMqttClientStatisticError!]
  gQL_MqttClientStatistics: GQL_MqttClientStatistics
  query: Query!
}

type RevokeApiTokenPayload {
  errors: [RevokeApiTokenError!]
  gQL_Token: GQL_Token
  query: Query!
}

type SaveMqttExplorerMessageTemplatePayload {
  errors: [SaveMqttExplorerMessageTemplateError!]
  gQL_MqttMessageTemplate: GQL_MqttMessageTemplate
  query: Query!
}

type SetEdgeDefaultNetworkAdapterPayload {
  errors: [SetEdgeDefaultNetworkAdapterError!]
  gQL_DefaultAdapter: GQL_DefaultAdapter
  query: Query!
}

type SetEdgeDescriptionPayload {
  errors: [SetEdgeDescriptionError!]
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeLocation1Payload {
  errors: [SetEdgeLocation1Error!]
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeLocation2Payload {
  errors: [SetEdgeLocation2Error!]
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeLocation3Payload {
  errors: [SetEdgeLocation3Error!]
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeNamePayload {
  errors: [SetEdgeNameError!]
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetMqttAuthUserPasswordPayload {
  errors: [SetMqttAuthUserPasswordError!]
  gQL_MqttAuthUser: GQL_MqttAuthUser
  query: Query!
}

type SetMqttServerClientCommunicationTimeoutPayload {
  errors: [SetMqttServerClientCommunicationTimeoutError!]
  gQL_MqttServerClientCfg: GQL_MqttServerClientCfg
  query: Query!
}

type SetMqttServerClientMaxPendingMessagesPayload {
  errors: [SetMqttServerClientMaxPendingMessagesError!]
  gQL_MqttServerClientCfg: GQL_MqttServerClientCfg
  query: Query!
}

type SetMqttServerClientPresistSessionPayload {
  errors: [SetMqttServerClientPresistSessionError!]
  gQL_MqttServerClientCfg: GQL_MqttServerClientCfg
  query: Query!
}

type SetMqttServerEndpointPayload {
  errors: [SetMqttServerEndpointError!]
  gQL_MqttServerEndpoint: GQL_MqttServerEndpoint
  query: Query!
}

type SetServerDescriptionPayload {
  errors: [SetServerDescriptionError!]
  gQL_IServer: GQL_IServer
  query: Query!
}

type SetServerLocationPayload {
  errors: [SetServerLocationError!]
  gQL_IServer: GQL_IServer
  query: Query!
}

type SetServerNamePayload {
  errors: [SetServerNameError!]
  gQL_IServer: GQL_IServer
  query: Query!
}

type SetUserAdminPayload {
  errors: [SetUserAdminError!]
  gQL_User: GQL_User
  query: Query!
}

type SetUserPasswordPayload {
  errors: [SetUserPasswordError!]
  gQL_User: GQL_User
  query: Query!
}

type Subscription {
  mqttBridgeSubscribe(server_id: ID! topic: String!): GQL_MqttMessage!
  mqttClientUpdated(server_id: ID!): GQL_MqttClient!
  mqttNewClient(server_id: ID!): GQL_MqttNewClient!
  mqttNewTopic(server_id: ID!): GQL_MqttNewTopic!
  mqttServerClientStatistics(client_id: ID! server_id: ID!): GQL_MqttClientStatsUpdate!
  mqttServerConfigState(server_id: ID!): GQL_ConfigMatch!
  mqttServerMetrics(metric: GQL_MqttServerMetricSource! server_id: ID!): GQL_ServerMetric!
  mqttServerNewMessage(client_id: ID server_id: ID! topic_id: ID): GQL_MqttMessage!
  mqttTopicUpdated(server_id: ID!): GQL_MqttTopic!
  runtimeMetric(source: GQL_RuntimeMetricSource!): GQL_Metric!
  serverStateChanged(server_id: ID!): GQL_ServerStateChangedNotification!
  systemTime: DateTime!
  uptime: GQL_Uptime!
}

type UpdateUserEnabledPayload {
  errors: [UpdateUserEnabledError!]
  gQL_User: GQL_User
  query: Query!
}

type UpdateUserFirstNamePayload {
  errors: [UpdateUserFirstNameError!]
  gQL_User: GQL_User
  query: Query!
}

type UpdateUserLastNamePayload {
  errors: [UpdateUserLastNameError!]
  gQL_User: GQL_User
  query: Query!
}

type UpdateWebHookActiveStatePayload {
  errors: [UpdateWebHookActiveStateError!]
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type UpdateWebHookEventGroupsPayload {
  errors: [UpdateWebHookEventGroupsError!]
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type UpdateWebHookNamePayload {
  errors: [UpdateWebHookNameError!]
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type UpdateWebHookSecretPayload {
  errors: [UpdateWebHookSecretError!]
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type UpdateWebHookUrlPayload {
  errors: [UpdateWebHookUrlError!]
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type ValidationError implements ResultError {
  errors: [ErrorSource!]
  errorType: String!
  message: String!
}

union CreateMqttAuthClientError = ValidationError | AuthorizationError | InternalError

union CreateMqttAuthUserError = ValidationError | AuthorizationError | InternalError

union CreateMqttServerExplorerUserSubError = ValidationError | AuthorizationError | InternalError

union CreateServerError = ValidationError | AuthorizationError | InternalError

union CreateUserError = ValidationError | AuthorizationError | InternalError

union CreateWebHookError = ValidationError | AuthorizationError | InternalError

union EnableDisableServerError = ValidationError | AuthorizationError | InternalError

union EnableGraphqlApiError = ValidationError | AuthorizationError | InternalError

union EnableMqttAuthClinetError = ValidationError | AuthorizationError | InternalError

union EnableMqttAuthUserError = ValidationError | AuthorizationError | InternalError

union EnableMqttClientAuthError = ValidationError | AuthorizationError | InternalError

union EnableMqttLoggingError = ValidationError | AuthorizationError | InternalError

union EnableMqttUserAuthError = ValidationError | AuthorizationError | InternalError

union EnableRestApiError = ValidationError | AuthorizationError | InternalError

union GQL_IServerEventUnion = GQL_ClientConnected | GQL_ServerConfigDiffEvent | GQL_ServerErrorEvent | GQL_ServerInfoEvent | GQL_ServerStateChangedEvent | GQL_ClientDisconnected

union GenerateApiTokenError = ValidationError | AuthorizationError | InternalError

union ProcessServerCmdError = ValidationError | AuthorizationError | InternalError

union PublishMqttMessageError = ValidationError | AuthorizationError | InternalError

union RemoveMqttAuthClientError = ValidationError | AuthorizationError | InternalError

union RemoveMqttAuthUserError = ValidationError | AuthorizationError | InternalError

union RemoveMqttServerExplorerUserSubError = ValidationError | AuthorizationError | InternalError

union RemoveMqttServerExplorerUserTemplateError = ValidationError | AuthorizationError | InternalError

union RemoveServerError = ValidationError | AuthorizationError | InternalError

union RemoveUserError = ValidationError | AuthorizationError | InternalError

union RemoveWebHookError = ValidationError | AuthorizationError | InternalError

union ResetMqttClientStatisticError = ValidationError | AuthorizationError | InternalError

union RevokeApiTokenError = ValidationError | AuthorizationError | InternalError

union SaveMqttExplorerMessageTemplateError = ValidationError | AuthorizationError | InternalError

union SetEdgeDefaultNetworkAdapterError = ValidationError | AuthorizationError | InternalError

union SetEdgeDescriptionError = ValidationError | AuthorizationError | InternalError

union SetEdgeLocation1Error = ValidationError | AuthorizationError | InternalError

union SetEdgeLocation2Error = ValidationError | AuthorizationError | InternalError

union SetEdgeLocation3Error = ValidationError | AuthorizationError | InternalError

union SetEdgeNameError = ValidationError | AuthorizationError | InternalError

union SetMqttAuthUserPasswordError = ValidationError | AuthorizationError | InternalError

union SetMqttServerClientCommunicationTimeoutError = ValidationError | AuthorizationError | InternalError

union SetMqttServerClientMaxPendingMessagesError = ValidationError | AuthorizationError | InternalError

union SetMqttServerClientPresistSessionError = ValidationError | AuthorizationError | InternalError

union SetMqttServerEndpointError = ValidationError | AuthorizationError | InternalError

union SetServerDescriptionError = ValidationError | AuthorizationError | InternalError

union SetServerLocationError = ValidationError | AuthorizationError | InternalError

union SetServerNameError = ValidationError | AuthorizationError | InternalError

union SetUserAdminError = ValidationError | AuthorizationError | InternalError

union SetUserPasswordError = ValidationError | AuthorizationError | InternalError

union UpdateUserEnabledError = ValidationError | AuthorizationError | InternalError

union UpdateUserFirstNameError = ValidationError | AuthorizationError | InternalError

union UpdateUserLastNameError = ValidationError | AuthorizationError | InternalError

union UpdateWebHookActiveStateError = ValidationError | AuthorizationError | InternalError

union UpdateWebHookEventGroupsError = ValidationError | AuthorizationError | InternalError

union UpdateWebHookNameError = ValidationError | AuthorizationError | InternalError

union UpdateWebHookSecretError = ValidationError | AuthorizationError | InternalError

union UpdateWebHookUrlError = ValidationError | AuthorizationError | InternalError

input CreateMqttAuthClientInput {
  clientId: String!
  server_uid: ID!
}

input CreateMqttAuthUserInput {
  password: String!
  server_uid: ID!
  userName: String!
}

input CreateMqttServerExplorerUserSubInput {
  color: String
  noLocal: Boolean!
  server_uid: ID!
  topic: String!
}

input CreateServerInput {
  description: String
  name: String!
  type: GQL_ServerVariant!
}

input CreateUserInput {
  first_name: String!
  last_name: String!
  password: String!
  user_name: String!
}

input CreateWebHookInput {
  groups: [HookEventGroup!]!
  name: String!
  secret: String
  server_id: ID
  url: String!
}

input EnableDisableServerInput {
  enable: Boolean!
  id: ID!
}

input EnableGraphqlApiInput {
  enable: Boolean!
}

input EnableMqttAuthClinetInput {
  authClient_id: ID!
  enable: Boolean!
}

input EnableMqttAuthUserInput {
  authUser_id: ID!
  enable: Boolean!
}

input EnableMqttClientAuthInput {
  enable: Boolean!
  server_uid: ID!
}

input EnableMqttLoggingInput {
  enable: Boolean!
  server_uid: ID!
}

input EnableMqttUserAuthInput {
  enable: Boolean!
  server_uid: ID!
}

input EnableRestApiInput {
  enable: Boolean!
}

input GenerateApiTokenInput {
  description: String!
  lifetime: TokenLifetime! = HOUR
  scope: TokenSkope! = VIEW
}

input ProcessServerCmdInput {
  cmd: GQL_ServerCmd!
  uid: ID!
}

input PublishMqttMessageInput {
  contentType: MessageContentType!
  expireInterval: Int!
  payload: String!
  qos: MessageQoS!
  retain: Boolean!
  server_uid: ID!
  topic: String!
}

input RemoveMqttAuthClientInput {
  authClientId: ID!
}

input RemoveMqttAuthUserInput {
  authUserId: ID!
}

input RemoveMqttServerExplorerUserSubInput {
  storedsub_id: ID!
}

input RemoveMqttServerExplorerUserTemplateInput {
  template_id: ID!
}

input RemoveServerInput {
  id: ID!
}

input RemoveUserInput {
  user_id: ID!
}

input RemoveWebHookInput {
  hook_id: ID!
}

input ResetMqttClientStatisticInput {
  client_uid: ID!
  server_uid: ID!
}

input RevokeApiTokenInput {
  token_id: ID!
}

input SaveMqttExplorerMessageTemplateInput {
  contentType: MessageContentType!
  expireInterval: Int!
  payload: String!
  qos: MessageQoS!
  retain: Boolean!
  server_uid: ID!
  topic: String!
}

input SetEdgeDefaultNetworkAdapterInput {
  adapter_id: ID!
}

input SetEdgeDescriptionInput {
  description: String!
}

input SetEdgeLocation1Input {
  location1: String!
}

input SetEdgeLocation2Input {
  location2: String!
}

input SetEdgeLocation3Input {
  location3: String!
}

input SetEdgeNameInput {
  name: String!
}

input SetMqttAuthUserPasswordInput {
  authUserId: ID!
  password: String!
}

input SetMqttServerClientCommunicationTimeoutInput {
  server_uid: ID!
  timeout_ms: Int!
}

input SetMqttServerClientMaxPendingMessagesInput {
  maxPendingMessages: Int!
  server_uid: ID!
}

input SetMqttServerClientPresistSessionInput {
  presistSession: Boolean!
  server_uid: ID!
}

input SetMqttServerEndpointInput {
  ip: String!
  port: Int!
  server_uid: ID!
}

input SetServerDescriptionInput {
  description: String!
  id: ID!
}

input SetServerLocationInput {
  id: ID!
  location: String!
}

input SetServerNameInput {
  id: ID!
  name: String!
}

input SetUserAdminInput {
  is_admin: Boolean!
  user_id: ID!
}

input SetUserPasswordInput {
  current_password: String!
  new_password: String!
  user_id: ID!
}

input UpdateUserEnabledInput {
  enable: Boolean!
  user_id: ID!
}

input UpdateUserFirstNameInput {
  first_name: String!
  user_id: ID!
}

input UpdateUserLastNameInput {
  last_name: String!
  user_id: ID!
}

input UpdateWebHookActiveStateInput {
  activ: Boolean!
  hook_id: ID!
}

input UpdateWebHookEventGroupsInput {
  groups: [HookEventGroup!]!
  hook_id: ID!
}

input UpdateWebHookNameInput {
  hook_id: ID!
  name: String!
}

input UpdateWebHookSecretInput {
  hook_id: ID!
  secret: String!
}

input UpdateWebHookUrlInput {
  hook_id: ID!
  url: String!
}

enum AdapterState {
  UNKNOWN
  DOWN
  UP
}

enum AuthAction {
  ALLOW
  DISALLOW
}

enum DTO_MqttProtocol {
  UNKNOWN
  V310
  V311
  V500
}

enum EventType {
  INFO
  WARNING
  ERROR
}

enum GQL_MqttServerMetricSource {
  CONNECTED_CLIENTS
  INBOUND_PACKETS
  OUTBOUND_PACKETS
  NOT_CONSUMED_MESSAGES
  TOPIC_SUBSCRIPTIONS
  TOPICS
}

enum GQL_RuntimeMetricSource {
  TOTAL_CPU_USED
  PRIVILEGED_CPU_USED
  USER_CPU_USED
  MEMORY_WORKING_SET
  NON_PAGED_SYSTEM_MEMORY
  PAGED_MEMORY
  PAGED_SYSTEM_MEMORY
  PRIVATE_MEMORY
  VIRTUAL_MEMORY
  GC_ALOCATED_MEMORY
  THREAD_COUNT
}

enum GQL_ScheduleState {
  "Awaiting"
  Awaiting
  "Deleted"
  Deleted
  "Enqueued"
  Enqueued
  "Failed"
  Failed
  "Processing"
  Processing
  "Scheduled"
  Scheduled
  "Succeeded"
  Succeeded
}

enum GQL_ServerCmd {
  STOP
  START
  RESTART
}

enum GQL_ServerState {
  UNDEFINED
  STOPPED
  STARTING
  STARTED
  STOPPING
  RESTARTING
  DISABLED
}

enum GQL_ServerVariant {
  MQTT
  OPC
}

enum HookEventGroup {
  SYSTEM
  MQTT
  OPC
  S7
}

enum MessageContentType {
  UNDEFINED
  TEXT
  JSON
}

enum MessageQoS {
  AT_MOST_ONCE
  AT_LEAST_ONCE
  EXACTLY_ONCE
}

enum MqttAction {
  PUBLISH
  SUBSCRIBE
  PUBLISH_AND_SUBSCRIBE
}

enum MqttNetLogLevel {
  VERBOSE
  INFO
  WARNING
  ERROR
}

enum MqttResultCode {
  SUCCESS
  UNSPECIFIED_ERROR
  MALFORMED_PACKET
  PROTOCOL_ERROR
  IMPLEMENTATION_SPECIFIC_ERROR
  UNSUPPORTED_PROTOCOL_VERSION
  CLIENT_IDENTIFIER_NOT_VALID
  BAD_USER_NAME_OR_PASSWORD
  NOT_AUTHORIZED
  SERVER_UNAVAILABLE
  SERVER_BUSY
  BANNED
  BAD_AUTHENTICATION_METHOD
  TOPIC_NAME_INVALID
  PACKET_TOO_LARGE
  QUOTA_EXCEEDED
  PAYLOAD_FORMAT_INVALID
  RETAIN_NOT_SUPPORTED
  QO_S_NOT_SUPPORTED
  USE_ANOTHER_SERVER
  SERVER_MOVED
  CONNECTION_RATE_EXCEEDED
}

enum NetworkInterfaceType {
  UNKNOWN
  ETHERNET
  TOKEN_RING
  FDDI
  BASIC_ISDN
  PRIMARY_ISDN
  PPP
  LOOPBACK
  ETHERNET3_MEGABIT
  SLIP
  ATM
  GENERIC_MODEM
  FAST_ETHERNET_T
  ISDN
  FAST_ETHERNET_FX
  WIRELESS80211
  ASYMMETRIC_DSL
  RATE_ADAPT_DSL
  SYMMETRIC_DSL
  VERY_HIGH_SPEED_DSL
  IP_OVER_ATM
  GIGABIT_ETHERNET
  TUNNEL
  MULTI_RATE_SYMMETRIC_DSL
  HIGH_PERFORMANCE_SERIAL_BUS
  WMAN
  WWANPP
  WWANPP2
}

enum PlatformID {
  WIN32_S
  WIN32_WINDOWS
  WIN32_NT
  WIN_CE
  UNIX
  XBOX
  MAC_OSX
  OTHER
}

enum RecordResult {
  UNDEFINED
  OK
  PARAM
  HTTP
  QUERY
}

enum ServerEventTypes {
  INFO
  WARNING
  ERROR
}

enum TokenLifetime {
  HOUR
  DAY
  WEEK
  MONTH
  YEAR
}

enum TokenSkope {
  VIEW
  VIEW_AND_WRITE
}

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("Deferred when true." if: Boolean "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @export(as: String) on FIELD

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("Streamed when true." if: Boolean "The initial elements that shall be send down to the consumer." initialCount: Int! = 0 "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String) on FIELD

scalar Any

"The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255."
scalar Byte

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `TimeSpan` scalar represents an ISO-8601 compliant duration type."
scalar TimeSpan