schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface GQL_IServer {
  configState: GQL_ServerConfigState
  description: String
  id: ID!
  isConfigMatch: Boolean
  location: String
  name: String!
  state: GQL_ServerState!
  type: GQL_ServerVariant!
  updated: DateTime!
  uptime: GQL_Uptime!
}

interface GQL_IServerEvent {
  asJson: String!
  description: String
  iD: ID!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

type ActivateWebHookPayload {
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type CreateServerPayload {
  gQL_IServer: GQL_IServer
  query: Query!
}

type CreateWebHookPayload {
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type DTO_AdapterAddresses {
  dhcpServerAddresses: [String!]!
  dnsAddresses: [String!]!
  gatewayAddresses: [String!]!
  multicastAddresses: [String!]!
  unicastAddresses: [String!]!
}

type DTO_AdapterStatistic {
  bytesReceived: Long!
  bytesSent: Long!
}

type EnableDisableServerPayload {
  gQL_IServer: GQL_IServer
  query: Query!
}

type GQL_Adapter implements Node {
  addresses: DTO_AdapterAddresses!
  description: String!
  id: ID!
  interfaceType: NetworkInterfaceType!
  logs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_AdapterLogConnection
  name: String!
  physicalAddress: String!
  state: AdapterState!
  statistic: DTO_AdapterStatistic!
  supportsIpv4: Boolean!
  supportsIpv6: Boolean!
}

"A connection to a list of items."
type GQL_AdapterConnection {
  "A list of edges."
  edges: [GQL_AdapterEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_Adapter]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_AdapterEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_Adapter
}

type GQL_AdapterLog {
  id: ID!
  state: AdapterState!
  timeStamp: DateTime!
}

"A connection to a list of items."
type GQL_AdapterLogConnection {
  "A list of edges."
  edges: [GQL_AdapterLogEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_AdapterLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_AdapterLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_AdapterLog
}

type GQL_ClientConnected implements GQL_IServerEvent {
  asJson: String
  clientId: String!
  description: String
  iD: ID!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ConfigMatch {
  isMatch: Boolean!
  server: GQL_IServer!
  timestamp: DateTime!
}

type GQL_CountByDate {
  count: Long!
  date: DateTime!
}

type GQL_CpuMetrics {
  id: ID!
  privilegedCpuUsed: Float!
  threadCount: Float!
  totalCpuUsed: Float!
  userCpuUsed: Float!
}

type GQL_DefaultAdapter {
  adapter: GQL_Adapter
  id: ID!
}

type GQL_Edge {
  description: String
  guid: String!
  id: ID!
  location: String
  location1: String
  location2: String
  location3: String
  name: String!
}

type GQL_FailedJob implements Node {
  exceptionDetails: String!
  exceptionMessage: String!
  exceptionType: String!
  failedAt: DateTime
  id: ID!
  inFailedState: Boolean!
  jobDetail: GQL_JobDetail
  jobName: String
  reason: String!
}

"A connection to a list of items."
type GQL_FailedJobConnection {
  "A list of edges."
  edges: [GQL_FailedJobEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_FailedJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_FailedJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_FailedJob
}

"A connection to a list of items."
type GQL_IServerConnection {
  "A list of edges."
  edges: [GQL_IServerEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_IServer]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_IServerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_IServer
}

"A connection to a list of items."
type GQL_IServerEventUnionConnection {
  "A list of edges."
  edges: [GQL_IServerEventUnionEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_IServerEventUnion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_IServerEventUnionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_IServerEventUnion
}

type GQL_JobDetail {
  jobId: String!
  lastState: String
  methodCall: String
  parametrs: [GQL_JobParameter!]!
}

type GQL_JobParameter {
  name: String!
  value: String!
}

type GQL_JobsStatistic implements Node {
  deleted: Long!
  enqueued: Long!
  failed: Long!
  id: ID!
  processing: Long!
  queues: Long!
  recentFailedByDate: [GQL_CountByDate!]!
  recentSucceededByDate: [GQL_CountByDate!]!
  recurring: Long!
  scheduled: Long!
  servers: Long!
  succeeded: Long!
}

type GQL_MemoryMetrics {
  getAlocatedMemory: Float!
  id: ID!
  memoryUssage: Float!
  memoryWorkingSet: Float!
  nonPagedMemory: Float!
  pagedMemory: Float!
  virtualMemory: Float!
}

type GQL_Metric {
  id: ID!
  name: String!
  serverUid: String!
  timeStamp: DateTime!
  type: String
  unit: String
  value: Any
}

type GQL_MqttClient {
  connectedAt: DateTime
  id: ID!
  protocol: GQL_MqttProtocol!
  rawId: String
  serverUid: String!
}

type GQL_MqttClientConnected {
  client: GQL_MqttClient!
  timeStamp: DateTime!
}

"A connection to a list of items."
type GQL_MqttClientConnection {
  "A list of edges."
  edges: [GQL_MqttClientEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttClient]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

type GQL_MqttClientDisconnected {
  client: GQL_MqttClient!
  timeStamp: DateTime!
}

"An edge in a connection."
type GQL_MqttClientEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttClient
}

type GQL_MqttClientSession {
  clientUid: ID!
  created: DateTime
  pendingMessages: Long!
  uid: ID!
}

"A connection to a list of items."
type GQL_MqttClientSessionConnection {
  "A list of edges."
  edges: [GQL_MqttClientSessionEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttClientSession]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttClientSessionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttClientSession
}

type GQL_MqttClientStatistics {
  bytesReceived: Long!
  bytesSent: Long!
  clientUid: ID!
  connectedTimestamp: DateTime
  lastNonKeepAlivePacketReceivedTimestamp: DateTime
  lastPacketReceivedTimestamp: DateTime
  lastPacketSentTimestamp: DateTime
  receivedApplicationMessagesCount: Long!
  receivedPacketsCount: Long!
  sentApplicationMessagesCount: Long!
  sentPacketsCount: Long!
  serverUid: ID!
}

type GQL_MqttNewInboundTopic {
  timeStamp: DateTime!
  topic: GQL_MqttServerTopicStat!
}

type GQL_MqttServer implements GQL_IServer & Node {
  configState: GQL_ServerConfigState
  description: String
  id: ID!
  isConfigMatch: Boolean!
  isEnabled: Boolean!
  isRunning: Boolean!
  location: String
  name: String!
  state: ServerState!
  type: GQL_ServerVariant!
  updated: DateTime!
  uptime: GQL_Uptime
}

type GQL_MqttServerClientCfg {
  communicationTimeout: Int!
  id: ID!
  maxPendingMessagesPerClient: Int!
  presistentSession: Boolean!
  serverUID: ID!
}

type GQL_MqttServerEndpoint {
  id: ID!
  iPAddress: String!
  port: Long!
  serverUid: ID!
}

type GQL_MqttServerStats {
  connectionsCount: Long!
  id: ID!
  notConsumedCount: Long!
  packetRcvCount: Long!
  packetSndCount: Long!
  publishedTopicCount: Long!
  subscribedTopicCount: Long!
  subscriptionsCount: Long!
}

type GQL_MqttServerTopicStat {
  count: Long!
  id: String!
  topic: String!
}

"A connection to a list of items."
type GQL_MqttServerTopicStatConnection {
  "A list of edges."
  edges: [GQL_MqttServerTopicStatEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttServerTopicStat]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttServerTopicStatEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttServerTopicStat
}

type GQL_OS {
  isBrowser: Boolean!
  platform: PlatformID!
  version: String
}

type GQL_RecurringJob implements Node {
  callName: String!
  createdAt: DateTime
  cron: String!
  error: String
  id: ID!
  jobDetail: GQL_JobDetail
  lastExecution: DateTime
  lastJobId: String!
  lastJobState: GQL_ScheduleState
  nextExecution: DateTime
  queue: String!
  removed: Boolean!
  retryAttempt: Int!
  timeZoneId: String!
}

"A connection to a list of items."
type GQL_RecurringJobConnection {
  "A list of edges."
  edges: [GQL_RecurringJobEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_RecurringJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_RecurringJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_RecurringJob
}

type GQL_RuntimeMetrics {
  cpuMetrics: GQL_CpuMetrics
  memoryMetrics: GQL_MemoryMetrics
  metricHistory(name: GQL_RuntimeMetricSource): [HistorianRecord]
}

type GQL_ServerConfigDiffEvent implements GQL_IServerEvent {
  asJson: String
  configJson: String
  currentConfigJson: String
  description: String
  iD: ID!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerConfigState {
  isConfigMatch: Boolean!
  offlineConfig: String
  offlineTimeStamp: DateTime
  onlineConfig: String
  onlineTimeStamp: DateTime
}

type GQL_ServerErrorEvent implements GQL_IServerEvent {
  asJson: String
  description: String
  exception: String
  iD: ID!
  json: String
  message: String!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerInfoEvent implements GQL_IServerEvent {
  asJson: String
  description: String
  iD: ID!
  message: String!
  name: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerMetric {
  description: String
  eventName: String!
  id: ID!
  meterName: String!
  timeStamp: DateTime!
  topic: String!
  unit: String
  value: Any
}

type GQL_ServerStateChangedEvent implements GQL_IServerEvent {
  asJson: String
  description: String
  iD: ID!
  name: String!
  serverUid: ID
  state: String!
  timeStamp: DateTime!
  type: ServerEventTypes!
}

type GQL_ServerStateChangedNotification {
  server_Uid: ID
  state: GQL_ServerState!
}

type GQL_SuccessJob implements Node {
  id: ID!
  inSucceededState: Boolean!
  jobDetail: GQL_JobDetail
  name: String!
  succeededAt: DateTime
  totalDuration: Long
}

"A connection to a list of items."
type GQL_SuccessJobConnection {
  "A list of edges."
  edges: [GQL_SuccessJobEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_SuccessJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_SuccessJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_SuccessJob
}

type GQL_SystemEvent {
  description: String
  iD: ID!
  json: String
  name: String!
  timeStamp: DateTime!
  type: EventType!
}

"A connection to a list of items."
type GQL_SystemEventConnection {
  "A list of edges."
  edges: [GQL_SystemEventEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_SystemEvent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_SystemEventEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_SystemEvent
}

type GQL_SystemInfo {
  appUrls: [String]
  id: ID
  machineName: String
  osVersion: GQL_OS
  processName: String
  serverDateTime: DateTime!
  targetFramework: String
  uptime: GQL_Uptime
}

type GQL_Uptime {
  days: Int!
  hours: Int!
  isValid: Boolean!
  minutes: Int!
  uptime: TimeSpan
}

type GQL_User implements Node {
  firstName: String
  id: ID!
  lastName: String
  name: String
  sessionId: String
}

type GQL_WebHook {
  contentType: String
  eventGroup: [HookEventGroup!]
  id: Long!
  isActive: Boolean!
  lastTrigger: DateTime
  secret: String
  serverUid: String
  webHookUrl: String!
}

"A connection to a list of items."
type GQL_WebHookConnection {
  "A list of edges."
  edges: [GQL_WebHookEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_WebHook]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_WebHookEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_WebHook
}

type GQL_WebHookRecord {
  exception: String!
  guid: String!
  id: Long!
  requestBody: String!
  requestHeaders: String!
  responseBody: String!
  result: RecordResult!
  statusCode: Int!
  timestamp: DateTime!
  webHookID: Long!
}

"A connection to a list of items."
type GQL_WebHookRecordConnection {
  "A list of edges."
  edges: [GQL_WebHookRecordEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_WebHookRecord]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_WebHookRecordEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_WebHookRecord
}

type HistorianRecord {
  timeStamp: DateTime
  value: Any
}

type Mutation {
  activateWebHook(input: ActivateWebHookInput!): ActivateWebHookPayload!
  createServer(request: CreateServerInput!): CreateServerPayload!
  createWebHook(input: CreateWebHookInput!): CreateWebHookPayload!
  enableDisableServer(
    input: EnableDisableServerInput!
  ): EnableDisableServerPayload!
  processServerCmd(input: ProcessServerCmdInput!): ProcessServerCmdPayload!
  removeServer(input: RemoveServerInput!): RemoveServerPayload!
  setEdgeDefaultNetworkAdapter(
    input: SetEdgeDefaultNetworkAdapterInput!
  ): SetEdgeDefaultNetworkAdapterPayload!
  setEdgeDescription(
    request: SetEdgeDescriptionInput!
  ): SetEdgeDescriptionPayload!
  setEdgeLocation1(request: SetEdgeLocation1Input!): SetEdgeLocation1Payload!
  setEdgeLocation2(request: SetEdgeLocation2Input!): SetEdgeLocation2Payload!
  setEdgeLocation3(request: SetEdgeLocation3Input!): SetEdgeLocation3Payload!
  setEdgeName(request: SetEdgeNameInput!): SetEdgeNamePayload!
  setMqttServerClientCommunicationTimeout(
    input: SetMqttServerClientCommunicationTimeoutInput!
  ): SetMqttServerClientCommunicationTimeoutPayload!
  setMqttServerClientMaxPendingMessages(
    input: SetMqttServerClientMaxPendingMessagesInput!
  ): SetMqttServerClientMaxPendingMessagesPayload!
  setMqttServerClientPresistSession(
    input: SetMqttServerClientPresistSessionInput!
  ): SetMqttServerClientPresistSessionPayload!
  setMqttServerEndpoint(
    input: SetMqttServerEndpointInput!
  ): SetMqttServerEndpointPayload!
  setServerDescription(
    input: SetServerDescriptionInput!
  ): SetServerDescriptionPayload!
  setServerLocation(input: SetServerLocationInput!): SetServerLocationPayload!
  setServerName(input: SetServerNameInput!): SetServerNamePayload!
  test: TestPayload!
  updateWebHookEventGroups(
    input: UpdateWebHookEventGroupsInput!
  ): UpdateWebHookEventGroupsPayload!
  updateWebHookSecret(
    input: UpdateWebHookSecretInput!
  ): UpdateWebHookSecretPayload!
  updateWebHookUrl(input: UpdateWebHookUrlInput!): UpdateWebHookUrlPayload!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type ProcessServerCmdPayload {
  gQL_ServerState: GQL_ServerState
  query: Query!
}

type Query {
  adapterById(id: ID!): GQL_Adapter!
  adapterLogs(
    adapter_id: ID!
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_AdapterLogConnection
  adapters(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_AdapterConnection
  defaultAdapter: GQL_DefaultAdapter!
  edgeInfo: GQL_Edge!
  failedJob(jobid: ID!): GQL_FailedJob!
  failedJobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_FailedJobConnection
  jobsStatistic: GQL_JobsStatistic!
  me: GQL_User
  mqttServerById(id: ID!): GQL_MqttServer!
  mqttServerClient(server_client_uid: ID!, server_uid: ID!): GQL_MqttClient!
  mqttServerClientConfig(server_uid: ID!): GQL_MqttServerClientCfg!
  mqttServerClients(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
    server_uid: ID!
  ): GQL_MqttClientConnection
  mqttServerClientSession(
    server_client_uid: ID!
    server_uid: ID!
  ): GQL_MqttClientSession!
  mqttServerClientStatistic(
    server_client_uid: ID!
    server_uid: ID!
  ): GQL_MqttClientStatistics!
  mqttServerEndpoint(server_uid: ID!): GQL_MqttServerEndpoint!
  mqttServerSessions(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
    server_uid: ID!
  ): GQL_MqttClientSessionConnection
  mqttServerStats(server_uid: ID!): GQL_MqttServerStats!
  mqttServerTopicStats(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
    server_uid: ID!
  ): GQL_MqttServerTopicStatConnection
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  recurringJob(jobid: ID!): GQL_RecurringJob!
  recurringJobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_RecurringJobConnection
  runtimeMetrics: GQL_RuntimeMetrics!
  serverLogById(log_id: ID!): GQL_IServerEventUnion!
  serverLogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
    server_id: ID!
  ): GQL_IServerEventUnionConnection
  servers(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_IServerConnection
  successJob(jobid: ID!): GQL_SuccessJob!
  successJobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_SuccessJobConnection
  systemInfo: GQL_SystemInfo!
  systemLogById(log_id: ID!): GQL_SystemEvent!
  systemLogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_SystemEventConnection
  testik(id: ID!): GQL_Adapter
  webHookRecords(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    hook_id: ID!
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_WebHookRecordConnection
  webHooks(
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the elements in the list that come before the specified cursor."
    before: String
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the last _n_ elements from the list."
    last: Int
  ): GQL_WebHookConnection
}

type RemoveServerPayload {
  query: Query!
  removed_id: ID
}

type SetEdgeDefaultNetworkAdapterPayload {
  gQL_DefaultAdapter: GQL_DefaultAdapter
  query: Query!
}

type SetEdgeDescriptionPayload {
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeLocation1Payload {
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeLocation2Payload {
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeLocation3Payload {
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetEdgeNamePayload {
  gQL_Edge: GQL_Edge
  query: Query!
}

type SetMqttServerClientCommunicationTimeoutPayload {
  gQL_MqttServerClientCfg: GQL_MqttServerClientCfg
  query: Query!
}

type SetMqttServerClientMaxPendingMessagesPayload {
  gQL_MqttServerClientCfg: GQL_MqttServerClientCfg
  query: Query!
}

type SetMqttServerClientPresistSessionPayload {
  gQL_MqttServerClientCfg: GQL_MqttServerClientCfg
  query: Query!
}

type SetMqttServerEndpointPayload {
  gQL_MqttServerEndpoint: GQL_MqttServerEndpoint
  query: Query!
}

type SetServerDescriptionPayload {
  gQL_IServer: GQL_IServer
  query: Query!
}

type SetServerLocationPayload {
  gQL_IServer: GQL_IServer
  query: Query!
}

type SetServerNamePayload {
  gQL_IServer: GQL_IServer
  query: Query!
}

type Subscription {
  mqttClientConnected(server_id: ID!): GQL_MqttClientConnected!
  mqttClientDisconnected(server_id: ID!): GQL_MqttClientDisconnected!
  mqttNewInboundTopic(server_id: ID!): GQL_MqttNewInboundTopic!
  mqttServerConfigState(server_id: ID!): GQL_ConfigMatch!
  mqttServerMetrics(
    metric: GQL_MqttServerMetricSource!
    server_id: ID!
  ): GQL_ServerMetric!
  runtimeMetric(source: GQL_RuntimeMetricSource!): GQL_Metric!
  serverStateChanged(server_id: ID!): GQL_ServerStateChangedNotification!
  systemTime: DateTime!
  uptime: GQL_Uptime!
}

type TestPayload {
  boolean: Boolean
  query: Query!
}

type UpdateWebHookEventGroupsPayload {
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type UpdateWebHookSecretPayload {
  gQL_WebHook: GQL_WebHook
  query: Query!
}

type UpdateWebHookUrlPayload {
  gQL_WebHook: GQL_WebHook
  query: Query!
}

union GQL_IServerEventUnion =
    GQL_ClientConnected
  | GQL_ServerConfigDiffEvent
  | GQL_ServerErrorEvent
  | GQL_ServerInfoEvent
  | GQL_ServerStateChangedEvent

input ActivateWebHookInput {
  activ: Boolean!
}

input CreateServerInput {
  description: String
  name: String!
  type: GQL_ServerVariant!
}

input CreateWebHookInput {
  groups: [HookEventGroup!]!
  secret: String
  url: String!
}

input EnableDisableServerInput {
  enable: Boolean!
  id: ID!
}

input ProcessServerCmdInput {
  cmd: GQL_ServerCmd!
  uid: ID!
}

input RemoveServerInput {
  id: ID!
}

input SetEdgeDefaultNetworkAdapterInput {
  adapter_id: ID!
}

input SetEdgeDescriptionInput {
  description: String!
}

input SetEdgeLocation1Input {
  location1: String!
}

input SetEdgeLocation2Input {
  location2: String!
}

input SetEdgeLocation3Input {
  location3: String!
}

input SetEdgeNameInput {
  name: String!
}

input SetMqttServerClientCommunicationTimeoutInput {
  server_uid: ID!
  timeout_ms: Int!
}

input SetMqttServerClientMaxPendingMessagesInput {
  maxPendingMessages: Int!
  server_uid: ID!
}

input SetMqttServerClientPresistSessionInput {
  presistSession: Boolean!
  server_uid: ID!
}

input SetMqttServerEndpointInput {
  ip: String!
  port: Int!
  server_uid: ID!
}

input SetServerDescriptionInput {
  description: String!
  id: ID!
}

input SetServerLocationInput {
  id: ID!
  location: String!
}

input SetServerNameInput {
  id: ID!
  name: String!
}

input UpdateWebHookEventGroupsInput {
  groups: [HookEventGroup!]!
}

input UpdateWebHookSecretInput {
  secret: String!
}

input UpdateWebHookUrlInput {
  url: String!
}

enum AdapterState {
  UNKNOWN
  DOWN
  UP
}

enum EventType {
  INFO
  WARNING
  ERROR
}

enum GQL_MqttProtocol {
  UNKNOWN
  V310
  V311
  V500
}

enum GQL_MqttServerMetricSource {
  CONNECTED_CLIENTS
  INBOUND_PACKETS
  OUTBOUND_PACKETS
  NOT_CONSUMED_MESSAGES
  TOPIC_SUBSCRIPTIONS
  TOPICS
}

enum GQL_RuntimeMetricSource {
  TOTAL_CPU_USED
  PRIVILEGED_CPU_USED
  USER_CPU_USED
  MEMORY_WORKING_SET
  NON_PAGED_SYSTEM_MEMORY
  PAGED_MEMORY
  PAGED_SYSTEM_MEMORY
  PRIVATE_MEMORY
  VIRTUAL_MEMORY
  GC_ALOCATED_MEMORY
  THREAD_COUNT
}

enum GQL_ScheduleState {
  "Awaiting"
  Awaiting
  "Deleted"
  Deleted
  "Enqueued"
  Enqueued
  "Failed"
  Failed
  "Processing"
  Processing
  "Scheduled"
  Scheduled
  "Succeeded"
  Succeeded
}

enum GQL_ServerCmd {
  STOP
  START
  RESTART
}

enum GQL_ServerState {
  UNDEFINED
  STOPPED
  STARTING
  STARTED
  STOPPING
  RESTARTING
  DISABLED
}

enum GQL_ServerVariant {
  MQTT
  OPC
}

enum HookEventGroup {
  SYSTEM
  MQTT
  OPC
  S7
}

enum NetworkInterfaceType {
  UNKNOWN
  ETHERNET
  TOKEN_RING
  FDDI
  BASIC_ISDN
  PRIMARY_ISDN
  PPP
  LOOPBACK
  ETHERNET3_MEGABIT
  SLIP
  ATM
  GENERIC_MODEM
  FAST_ETHERNET_T
  ISDN
  FAST_ETHERNET_FX
  WIRELESS80211
  ASYMMETRIC_DSL
  RATE_ADAPT_DSL
  SYMMETRIC_DSL
  VERY_HIGH_SPEED_DSL
  IP_OVER_ATM
  GIGABIT_ETHERNET
  TUNNEL
  MULTI_RATE_SYMMETRIC_DSL
  HIGH_PERFORMANCE_SERIAL_BUS
  WMAN
  WWANPP
  WWANPP2
}

enum PlatformID {
  WIN32_S
  WIN32_WINDOWS
  WIN32_NT
  WIN_CE
  UNIX
  XBOX
  MAC_OSX
  OTHER
}

enum RecordResult {
  UNDEFINED
  OK
  PARAMETER_ERROR
  HTTP_ERROR
  DATA_QUERY_ERROR
}

enum ServerEventTypes {
  INFO
  WARNING
  ERROR
}

enum ServerState {
  UNDEFINED
  STOPPED
  STARTING
  STARTED
  STOPPING
  RESTARTING
  DISABLED
}

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer(
  "Deferred when true."
  if: Boolean
  "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to."
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @export(as: String) on FIELD

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy(
  "The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types."
  url: String!
) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream(
  "Streamed when true."
  if: Boolean
  "The initial elements that shall be send down to the consumer."
  initialCount: Int! = 0
  "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to."
  label: String
) on FIELD

scalar Any

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https://www.graphql-scalars.com/date-time")

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `TimeSpan` scalar represents an ISO-8601 compliant duration type."
scalar TimeSpan
