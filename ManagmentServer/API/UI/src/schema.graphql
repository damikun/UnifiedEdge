schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface GQL_IServer {
  description: String
  id: ID!
  location: String
  name: String!
  state: GQL_ServerState!
  type: GQL_ServerVariant!
  updated: DateTime!
  uptime: GQL_Uptime!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

type CreateMqttServerPayload {
  gQL_MqttServer: GQL_MqttServer
  query: Query!
}

type CreateOpcServerPayload {
  gQL_OpcServer: GQL_OpcServer
  query: Query!
}

type CreateServerPayload {
  gQL_IServer: GQL_IServer
  query: Query!
}

type GQL_CpuMetrics {
  id: ID!
  privilegedCpuUsed: Float!
  threadCount: Float!
  totalCpuUsed: Float!
  userCpuUsed: Float!
}

type GQL_Edge {
  description: String
  guid: String!
  location: String
  location1: String
  location2: String
  location3: String
  name: String!
}

"A connection to a list of items."
type GQL_IServerConnection {
  "A list of edges."
  edges: [GQL_IServerEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_IServer]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_IServerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_IServer
}

type GQL_MemoryMetrics {
  getAlocatedMemory: Float!
  id: ID!
  memoryUssage: Float!
  memoryWorkingSet: Float!
  nonPagedMemory: Float!
  pagedMemory: Float!
  virtualMemory: Float!
}

type GQL_Metric {
  category: String!
  id: ID!
  name: String!
  source: String!
  timeStamp: DateTime!
  type: String
  unit: String
  value: Any
}

type GQL_MqttServer implements GQL_IServer & Node {
  description: String
  id: ID!
  isRunning: Boolean!
  location: String
  name: String!
  port: Int!
  state: MqttState!
  type: GQL_ServerVariant!
  updated: DateTime!
  uptime: GQL_Uptime
}

"A connection to a list of items."
type GQL_MqttServerConnection {
  "A list of edges."
  edges: [GQL_MqttServerEdge!]
  "A flattened list of the nodes."
  nodes: [GQL_MqttServer]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GQL_MqttServerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GQL_MqttServer
}

type GQL_OS {
  isBrowser: Boolean!
  platform: PlatformID!
  version: String
}

type GQL_OpcServer implements GQL_IServer {
  description: String
  id: String!
  isRunning: Boolean!
  location: String
  name: String!
  port: Int!
  state: GQL_ServerState!
  type: GQL_ServerVariant!
  updated: DateTime!
  uptime: GQL_Uptime!
}

type GQL_RuntimeMetrics {
  cpuMetrics: GQL_CpuMetrics
  memoryMetrics: GQL_MemoryMetrics
  metricHistory(name: GQL_RuntimeMetricSource): [HistorianRecord]
}

type GQL_SystemInfo {
  appUrls: [String]
  id: ID
  machineName: String
  osVersion: GQL_OS
  processName: String
  serverDateTime: DateTime!
  targetFramework: String
  uptime: GQL_Uptime
}

type GQL_Uptime {
  days: Int!
  hours: Int!
  isValid: Boolean!
  minutes: Int!
  uptime: TimeSpan
}

type GQL_User implements Node {
  firstName: String
  id: ID!
  lastName: String
  name: String
  sessionId: String
}

type HistorianRecord {
  timeStamp: DateTime
  value: Any
}

type Mutation {
  createMqttServer(request: CreateMqttServerInput): CreateMqttServerPayload!
  createOpcServer(request: CreateOpcServerInput): CreateOpcServerPayload!
  createServer(request: CreateServerInput!): CreateServerPayload!
  removeMqttServer(input: RemoveMqttServerInput!): RemoveMqttServerPayload!
  true: TruePayload!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type Query {
  edgeInfo: GQL_Edge!
  me: GQL_User
  mqttServerById(id: ID!): GQL_MqttServer!
  mqttServers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_MqttServerConnection
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  runtimeMetrics: GQL_RuntimeMetrics!
  servers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GQL_IServerConnection
  systemInfo: GQL_SystemInfo!
  test: Boolean!
}

type RemoveMqttServerPayload {
  query: Query!
  string: String
}

type Subscription {
  runtimeMetric(source: GQL_RuntimeMetricSource!): GQL_Metric!
  systemTime: DateTime!
  uptime: GQL_Uptime!
}

type TruePayload {
  boolean: Boolean
  query: Query!
}

input CreateMqttServerInput {
  description: String
  name: String
  port: Int!
}

input CreateOpcServerInput {
  description: String
  name: String
}

input CreateServerInput {
  description: String
  name: String!
  type: GQL_ServerVariant!
}

input RemoveMqttServerInput {
  request: RemoveServerInput!
}

input RemoveServerInput {
  id: String
}

enum GQL_RuntimeMetricSource {
  TOTAL_CPU_USED
  PRIVILEGED_CPU_USED
  USER_CPU_USED
  MEMORY_WORKING_SET
  NON_PAGED_SYSTEM_MEMORY
  PAGED_MEMORY
  PAGED_SYSTEM_MEMORY
  PRIVATE_MEMORY
  VIRTUAL_MEMORY
  GC_ALOCATED_MEMORY
  THREAD_COUNT
}

enum GQL_ServerState {
  UNKNOWN
  STOPPED
  STOPPING
  RESTARTING
  STARTING
  RUNNING
}

enum GQL_ServerVariant {
  MQTT
  OPC
}

enum MqttState {
  UNKNOWN
  STOPPED
  STOPPING
  RESTARTING
  STARTING
  RUNNING
}

enum PlatformID {
  WIN32_S
  WIN32_WINDOWS
  WIN32_NT
  WIN_CE
  UNIX
  XBOX
  MAC_OSX
  OTHER
}

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("Deferred when true." if: Boolean "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @export(as: String) on FIELD

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("Streamed when true." if: Boolean "The initial elements that shall be send down to the consumer." initialCount: Int! = 0 "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String) on FIELD

scalar Any

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `TimeSpan` scalar represents an ISO-8601 compliant duration type."
scalar TimeSpan